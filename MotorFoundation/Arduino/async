

{
  int fd,res;
  struct termios oldtio,newtio;
  struct sigaction saio;     /* definition of signal action */
  char buf[255];

  /* open the device to be non-blocking (read will return immediatly) */
  fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY | O_NONBLOCK);
  if (fd <0) {perror(MODEMDEVICE); return 0; }

  /* install the signal handler before making the device asynchronous */
  saio.sa_handler = signal_handler_IO;
  //saio.sa_mask = 0;
  saio.sa_flags = 0;
  saio.sa_restorer = NULL;
  sigaction(SIGIO,&saio,NULL);

  /* allow the process to receive SIGIO */
  fcntl(fd, F_SETOWN, getpid());
  /* Make the file descriptor asynchronous (the manual page says only
     O_APPEND and O_NONBLOCK, will work with F_SETFL...) */
  fcntl(fd, F_SETFL, FASYNC);

  tcgetattr(fd,&oldtio); /* save current port settings */
  /* set new port settings for canonical input processing */
  newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
  newtio.c_iflag = IGNPAR | ICRNL;
  newtio.c_oflag = 0;
  newtio.c_lflag = ICANON;
  newtio.c_cc[VMIN]=40;//1;
  newtio.c_cc[VTIME]=0;
  tcflush(fd, TCIFLUSH);
  tcsetattr(fd,TCSANOW,&newtio);

  /* loop while waiting for input. normally we would do something
     useful here */
  while (STOP==FALSE) {
                         printf(".\n");
                         usleep(100000);
                         /* after receiving SIGIO, wait_flag = FALSE, input is available and can be read */
                         if (wait_flag==0)
                         {
                           res = read(fd,buf,255);
                           buf[res]=0;
                           printf(":%s:%d\n", buf, res);
                           if (res==1) STOP=1; /* stop loop if only a CR was input */
                           wait_flag = 1;/* wait for new input */
                          }
                     }
  /* restore old port settings */
  tcsetattr(fd,TCSANOW,&oldtio);
  return 0;
}
